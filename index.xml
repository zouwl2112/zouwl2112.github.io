<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>wl2112</title>
    <link>https://zouwl2112.github.io/</link>
    <description>Recent content on wl2112</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 30 Nov 2019 16:09:07 +0800</lastBuildDate>
    
	<atom:link href="https://zouwl2112.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>数据结构复习</title>
      <link>https://zouwl2112.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Sat, 30 Nov 2019 16:09:07 +0800</pubDate>
      
      <guid>https://zouwl2112.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</guid>
      <description>数据结构复习汇总 #简介 为了复习和保存思路，我将数据结构课程所学的各种知识汇总在此，并加上我对各种结构的理解及实现代码。
#数据结构实现思路及代码 #第一章：绪论 #结构： 数据是能输入到计算机并被计算机理解的符号集合，在这个集合中的各个元素被称为数据元素，具有相同性质的数据元素的集合被称为数据对象，数据对象是数据的一个子集。
结构指数据之间存在的联系。数据之间的逻辑关系被称为逻辑结构，数据在计算机中的物理关系被称为物理结构（存储结构）。
逻辑结构大致分为***集合、线性结构（顺序表，链表）、非线性结构（树，图）***几类。
物理结构一般包含线性存储结构、链式存储结构、索引结构和散列结构。
#算法： 算法指解决某个特定问题的指令集合。
一个完整算法必须包含输入、输出、有穷性、确定性以及有效性。算法独立于与具体的计算机，与语言无关。
分析一个算法好坏一般用算法的时间复杂度和空间复杂度。分析时间复杂度使用频度统计法，及计算某条语句被重复执行的次数。空间复杂度的计算要考虑多方面因素，不展开讲解。
 第一章绪论部分较为枯燥，但概念十分重要。 #第二章：线性表 线性表是指由属于同一数据对象的n个数据元素组成的有序集合。一个线性表只有一个头结点和一个尾结点，头结点没有前驱，尾结点没有后继，其他元素只有一个前驱和一个后继。线性表有两种基本的存储结构：顺序存储和链式存储。
线性表的基本操作一般为创建、插入、删除、查找、求线性表长度等等。
#顺序表： 顺序表在存储结构上是一组连续地址的空间，表中的元素依次放在空间中。
使用顺序表必须事先分配空间，但是因为数据元素的数量不好估计，所以用以造成空间浪费或者空间不足，并且分配的空间地址必须是连续的。但是顺序表中的元素可以随机访问比较方便，且在已知数据个数及第个元素的地址是数据元素的地址比较容易计算，另外顺序表的空间中只需要存储数据元素本身的信息，空间开销较小。
顺序表的结构描述：
#define MAXSIZE 100 //顺序表的最大长度 #define Elemtype int Elemtype A[MAXSIZE]; int n; //顺序表的实际长度 顺序表的创建：
void Create(Elemtype a[],int &amp;amp;n) { cin&amp;gt;&amp;gt;n; //输入数据的数量  for(int i=1;i&amp;lt;=n;i++){ cin&amp;gt;&amp;gt;a[i]; //输入数据  } } 顺序表的插入：
void Insert(Elemtype a[],Elemtype item,int &amp;amp;n,int key) /*item为需要插入的数据，key为插入的位置*/ { if(n==MAXSIZE-1||key&amp;lt;1||key&amp;gt;n+1){ return; //若顺序表已满或插入位置不符合规范，则退出 	} for(int i=n;i&amp;gt;=key;i--){ a[i+1]=a[i]; //使从第key个开始的元素向后移一位  } a[key]=item; n=n+1; } 顺序表的删除：</description>
    </item>
    
  </channel>
</rss>